/**
 * Stacks Blockchain Integration (Simplified)
 * 
 * Utilities for interacting with BitSave smart contracts on Stacks testnet
 */

import {
  openContractCall,
  FinishedTxData,
} from '@stacks/connect';
import { CONTRACTS, API_URL } from './contracts';

/**
 * Deposit STX into BitSave savings
 */
export async function depositSTX(
  senderAddress: string,
  lockPeriod: number,
  onFinish: (data: FinishedTxData) => void,
  onCancel: () => void
) {
  await openContractCall({
    contractAddress: CONTRACTS.bitsave.address,
    contractName: CONTRACTS.bitsave.name,
    functionName: 'deposit',
    functionArgs: [`u${lockPeriod}`],
    network: 'testnet',
    onFinish,
    onCancel,
  });
}

/**
 * Withdraw STX from BitSave savings
 */
export async function withdrawSTX(
  senderAddress: string,
  onFinish: (data: FinishedTxData) => void,
  onCancel: () => void
) {
  await openContractCall({
    contractAddress: CONTRACTS.bitsave.address,
    contractName: CONTRACTS.bitsave.name,
    functionName: 'withdraw',
    functionArgs: [],
    network: 'testnet',
    onFinish,
    onCancel,
  });
}

/**
 * Get user's savings information from API
 */
export async function getUserSavings(userAddress: string) {
  try {
    const response = await fetch(
      `${API_URL}/v2/contracts/call-read/${CONTRACTS.bitsave.address}/${CONTRACTS.bitsave.name}/get-savings`,
      {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          sender: userAddress,
          arguments: [`0x${Buffer.from(userAddress).toString('hex')}`],
        }),
      }
    );
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Error fetching savings:', error);
    return null;
  }
}

/**
 * Get user's reputation points from API
 */
export async function getUserReputation(userAddress: string): Promise<number> {
  try {
    const response = await fetch(
      `${API_URL}/v2/contracts/call-read/${CONTRACTS.bitsave.address}/${CONTRACTS.bitsave.name}/get-reputation`,
      {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          sender: userAddress,
          arguments: [`0x${Buffer.from(userAddress).toString('hex')}`],
        }),
      }
    );
    const data = await response.json();
    
    if (data.okay && data.result) {
      // Parse hex result to number
      const hexValue = data.result.replace('0x', '');
      return parseInt(hexValue, 16) || 0;
    }
    
    return 0;
  } catch (error) {
    console.error('Error fetching reputation:', error);
    return 0;
  }
}

/**
 * Get current reward rate
 */
export async function getRewardRate(): Promise<number> {
  try {
    const response = await fetch(
      `${API_URL}/v2/contracts/call-read/${CONTRACTS.bitsave.address}/${CONTRACTS.bitsave.name}/get-reward-rate`,
      {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          sender: CONTRACTS.bitsave.address,
          arguments: [],
        }),
      }
    );
    const data = await response.json();
    
    if (data.okay && data.result) {
      const hexValue = data.result.replace('0x', '');
      return parseInt(hexValue, 16) || 10;
    }
    
    return 10;
  } catch (error) {
    console.error('Error fetching reward rate:', error);
    return 10;
  }
}

/**
 * Get user's STX balance
 */
export async function getUserSTXBalance(address: string): Promise<number> {
  try {
    const response = await fetch(
      `${API_URL}/extended/v1/address/${address}/stx`
    );
    const data = await response.json();
    
    // Balance is in micro-STX, convert to STX
    return Number(data.balance) / 1000000 || 0;
  } catch (error) {
    console.error('Error fetching STX balance:', error);
    return 0;
  }
}

/**
 * Get badges owned by user
 */
export async function getUserBadges(userAddress: string): Promise<any[]> {
  try {
    const response = await fetch(
      `${API_URL}/extended/v1/tokens/nft/holdings?principal=${userAddress}&asset_identifiers=${CONTRACTS.bitsaveBadges.fullId}::bitsave-badge`
    );
    const data = await response.json();
    
    return data.results || [];
  } catch (error) {
    console.error('Error fetching badges:', error);
    return [];
  }
}

/**
 * Parse transaction result
 */
export function parseTxResult(txData: FinishedTxData) {
  return {
    txId: txData.txId,
    
    txUrl: `https://explorer.hiro.so/txid/${txData.txId}?chain=testnet`,
  };
}

/**
 * Convert micro-STX to STX
 */
export function microStxToStx(microStx: number | string): number {
  return Number(microStx) / 1000000;
}

/**
 * Convert STX to micro-STX
 */
export function stxToMicroStx(stx: number): number {
  return Math.floor(stx * 1000000);
}

/**
 * Format STX amount for display
 */
export function formatSTX(amount: number): string {
  return amount.toLocaleString('en-US', {
    minimumFractionDigits: 2,
    maximumFractionDigits: 6,
  });
}
